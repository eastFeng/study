package com.dongfeng.study.basicstudy.sourcecode.java8.util.concurrent.locks;

/**
 * ReadWriteLock维护一对关联的锁，一个用于只读操作，另一个用于写操作。
 * 只要没有写入程序，读取锁就可以由多个读取器线程同时保持。写锁是独占的。
 *
 * <p>
 * 所有ReadWriteLock的实现类都必须保证writeLock操作的内存同步效果也适用于关联的ReadLock。
 * 也就是说成功获取读锁的线程将看到在写锁的先前版本上所做的所有更新。
 * </p>
 *
 * <p>
 * 读写锁允许访问共享数据的并发级别高于互斥锁允许的并发级别。
 * 它利用了这样一个事实：虽然一次只有一个线程（writer线程）可以修改共享数据，但在许多情况下，任意数量的线程都可以同时读取数据（因此是reader线程）。
 * 从理论上讲，使用读写锁所允许的并发性的增加将比使用互斥锁带来性能的提高。
 * 实际上，只有在多处理器上，并且只有在共享数据的访问模式合适的情况下，才能完全实现并发性的增加。
 * </p>
 *
 * <p>
 * 与互斥锁（mutual exclusion lock）相比，读写锁是否会提高性能取决于读取数据的频率（与被修改的频率相比）、读写操作的持续时间以及对数据的争用
 * （也就是说，同时尝试读取或写入数据的线程数）。例如，一个集合最初用数据填充，然后不经常修改，同时被频繁搜索（例如某种目录），是使用读写锁的理想候选。
 * 但是，如果更新变得频繁，那么数据的大部分时间都被独占锁定，并发性几乎没有增加。
 * 此外，如果读操作太短，则读写锁实现的开销（其本质上比互斥锁更复杂）可以控制执行成本，特别是当许多读写锁实现仍然通过一小段代码序列化所有线程时。
 * 最终，只有评测和测量才能确定读写锁的使用是否适合您的应用程序。
 * </p>
 *
 * <p>
 * 尽管读写锁的基本操作是直接的，但是实现的时候必须做出许多决策，这可能影响读写锁在程序中的效率。比如：
 * </p>
 * <ul>
 * <li>当读锁和写锁都在等待时，在写锁释放锁时，确定授予读锁还是写锁。
 * 偏向写锁是常见的，因为写时间短且不频繁。
 * 偏向读锁不太常见，因为如果读锁很频繁而且花费时间长，那么可能导致写操作长时间延迟。
 * 公平或者有序的实现也是可能的。</li>
 * <li>确定在读取处于活动状态，而写锁正在等待，是否授予读锁</li>
 * <li>确定锁是否可重入：具有写锁的线程能否重新获取它？它能在保持写锁的同时获取读锁吗？读锁本身可重入吗？</li>
 * <li>写锁是否可以降级为读锁而不允许中间的写入程序？读锁是否可以升级为写锁，优先于其他等待的读锁或写锁？</li>
 * </ul>
 * 应该考虑所有这些因素
 *
 * @author eastFeng
 * @date 2021-01-19 19:07
 */
public interface ReadWriteLock {

    /**
     * 返回用于读取的锁。
     *
     * @return 用来读取的锁
     */
    Lock readLock();

    /**
     * 返回用于写入的锁。
     *
     * @return 用于写入的锁
     */
    Lock writeLock();
}
