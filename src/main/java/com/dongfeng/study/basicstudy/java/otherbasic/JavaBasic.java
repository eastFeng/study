package com.dongfeng.study.basicstudy.java.otherbasic;

import java.util.Arrays;
import java.util.Date;

/**
 * <b> 一些Java基础学习 </b>
 *
 * @author eastFeng
 * @date 2021-04-19 15:17
 */
public class JavaBasic {

    /**
     * main方法也是一个静态方法。
     * main方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。
     * 每一个类可以有一个main方法。这是一个常用于对类进行单元测试的技巧。
     *
     * @param args 这个参数表明main方法将接收一个字符串数组，也就是命令行参数。
     */
    public static void main(String[] args) {
        Arrays.stream(args).forEach(System.out::println);

        // 基本数据类型
        primitiveType();

        // 数组
        array();

        // 面向对象
        classAndObject();

        // 方法参数的传递方式
        methodParameters();

        // 多态
        polymorphism();

        // 访问修饰符
        accessModifier();

        // 类的加载过程
        classRun();

//        JavaBasic.H = 100;
        System.out.println(JavaBasic.H);
    }

    // 数据类型：Java是一种强类型语言。这意味着必须为每一个变量声明一种类型。
    /**
     * Java是一种强类型语言。这意味着必须为每一个变量声明一种类型。
     * 在Java中，一共有八中基本类型：
     * <lo>
     *     <li> 4种整形：byte，short，int，long
     *     <li> 2中浮点类型：float，double
     *     <li> 1种用于表示Unicode编码的字符单元的字符类型：char
     *     <li> 1种用于表示真值的boolean类型。
     * </lo>
     */
    public static void primitiveType(){
        // --------------------------------- 整形 ---------------------------------------
        /*
         * 在Java中，整型的范围与运行Java代码的机器无关。
         * 这就解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。
         */

        /*
         * byte : 占1个字节 byte数据类型是一个8位、有符号的，以二进制补码表示的整数；
         * byte即字节，占1字节，由八位二进制组成。
         * byte类型的取值范围：[-128, 127] ---> [-2^7, 2^7-1]
         * byte类型主要用于需要控制占用存储空间量的大数组中，主要代替int类型
         * 因为byte变量占用的空间只有int类型的四分之一。
         * 默认值：0
         */
        byte b1 = 100;

        /*
         * short : 占2个字节（也就是16位）
         * short数据类型是16位、有符号的以二进制补码表示的整数
         * short类型的取值范围：[-32768, 327767] ---> [-2^15, 2^15-1]
         * short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；
         * 默认值：0
         *
         * byte和short类型主要用于特定的应用场合，例如，底层的文件处理或者需要控制占用存储空间量的大数组。
         */
        short s1 = 1000;

        /*
         * int : 占4个字节。int类型最常用。
         * int数据类型是32位、有符号的以二进制补码表示的整数；
         * int类型取值范围：[-2147483648, 2147483647] ---> [-2^31, 2^31-1] ,,, 正好超过20亿
         * 一般地整型变量默认为int类型；
         * 默认值：0
         */
        int a = 123456;

        /*
         * long : 长整型，占8个字节。
         * long 数据类型是 64 位、有符号的以二进制补码表示的整数；
         * long类型取值范围：[-9223372036854775808, 9223372036854775807] ---> [-2^64, 2^63-1]
         * long类型主要使用在需要比较大整数的系统上；
         * 长整型数值有一个后缀L或l（如4000000000L），小写的l容易与数字1混淆，所以最好大写
         * 默认值是 0L；
         */
        long l1 = 4000000000L;

        // ---------------------------- 浮点类型 ----------------------------------------
        /*
         * 浮点类型用于表示有小数部分的数值。在Java中有两种浮点类型: float, double。
         * 浮点数不能用来表示精确的值，如货币
         */

        /*
         * float : 单精度、占4个字节
         * float 数据类型是单精度、32位、符合IEEE 754标准的浮点数
         * float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）默认为double类型
         * float 在储存大型浮点数组的时候可节省内存空间
         * 默认值 : 0.0f
         */
        float f1 = 0.1f;

        /*
         * double : 双精度、占8个字节
         * double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；
         * double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值）。
         * 浮点数的默认类型为 double 类型
         * 默认值 : 0.0
         */
        double d1 = 3.336;

        // ---------------------------- char类型 ----------------------------------------
        /*
         * char : 占两个字节
         * char类型是一个单一的 16 位 Unicode 字符；
         * char类型的字面量值要用单引号括起来。例如：'A'
         * 最小值是 \u0000（即为 0），最大值是 \uffff（即为 65535）；
         * char类型原本用于表示单个字符。不过，现在情况已经有所变化。
         * 如今，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。
         */
        char c1 = 'A';
        char c2 = 65;

        // ---------------------------- boolean类型 ----------------------------------------
        /*
         * boolean数据类型表示一位的信息；
         * boolean（布尔）类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。
         * 默认值是 false；
         */
        boolean flag = true;

        /*
         * Java中， 变量名必须是一个以字母开头并由字母或数字构成的序列。变量名中所有的字符都是有意义的，并且大小写敏感。变量名的长度基本上没有限制。
         * 声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量。
         * 在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。
         * 在Java中，利用关键字final指示常量。
         * 关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。
         * 在Java中，经常希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量。可以使用关键字static final设置一个类常量。
         */
        final String FINAL_DEMO = "love";


        /*
         * 当使用两个数值进行二元操作时（例如n + f, n是整数，f是浮点数），先要将两个操作数转换为同一种类型，然后再进行计算。
         * ● 如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。
         * ● 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。
         * ● 否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。
         * ● 否则，两个操作数都将被转换为int类型。
         */
        double v = d1 + f1;

        // 强制类型转换（cast）：将一个类型强制转换成另外一个类型的过程被称为类型转换。
        // 强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名
        int dCast = (int) d1;

        /*
         * 处理整型类型时，可以直接对组成整型数值的各个位完成操作。
         * 位运算符有：
         * & : 相位与（相同位上面，同为1结果才为1，否则结果为0）
         * | : 相位或（相同位上面，只要有一个是1结果就是1，只有两个都为0结果才为0）
         * ^ : 异或（相同位上面，相同为0，不同为1）
         * ~ : 非（0变1，1变0）
         */
        int i = 12 ^ 16;


    }

    /**
     * 在Java中，经常希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量。可以使用关键字static final设置一个类常量。
     * 而且，如果一个常量被声明为public，那么其他类的方法也可以使用这个常量。
     */
    private static final String STUDY_URL = "https://www.nowcoder.com/interview/center";


    /**
     * <b> 数组是一种数据结构，用来存储同一类型值的集合。 </b>
     * <p> 通过一个整型下标可以访问数组中的每一个值。例如，如果a是一个整型数组，a[i]就是数组中下标为i的整数。
     */
    public static void array(){
        // 在声明数组变量时，需要指出数组类型（数据元素类型紧跟[]）和数组变量的名字。
        int[] a;

        // 不过，上条语句只声明了变量a，并没有将a初始化为一个真正的数组。应该使用new运算符创建数组。
        a = new int[100];  // 创建了一个可以存储100个整数的数组。数组长度不要求是常量：new int[n]会创建一个长度为n的数组。

        // 创建一个数字数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。
        // 对象数组的元素则初始化为一个特殊值null，这表示这些元素（还）未存放任何对象。

        // 一旦创建了数组，就可以给数组元素赋值
        for (int i=0; i<100; i++){
            a[i] = i;
        }

        // 创建数组对象并同时赋予初始值的简化书写形式。
        // 这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的个数
        int[] smallPrimes = {1, 22, -1, 0, 3, 66};
    }

    /**
     * <b> 面向对象（Object Oriented Programming，简称OOP）四大基本特性：抽象，封装，继承，多态。 </b>
     *
     * <p> 面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。
     * 类（class）是构造对象的模板或蓝图。由类构造（construct）对象的过程称为创建类的实例（instance）。
     *
     * <p> 封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。
     * 对象中的数据称为实例域（instance field），操纵数据的过程称为方法（method）。
     * 对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state）
     * 实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。这是提高重用性和可靠性的关键。
     *
     * <p> OOP的另一个原则会让用户自定义Java类变得轻而易举，这就是：可以通过扩展一个类来建立另外一个新的类。
     * 在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法。通过扩展一个类来建立另外一个类的过程称为继承（inheritance)。
     *
     * <p> 要想使用对象，就必须首先构造对象，并指定其初始状态。在Java程序设计语言中，使用构造器（constructor）构造新实例。
     * 构造器是一种特殊的方法，用来构造并初始化对象。
     *
     * <p> 类设计技巧：
     * <ol>
     *     <li> 一定要保证数据私有。 ： 这是最重要的；绝对不要破坏封装性。
     *     <li> 一定要对数据初始化。
     *     <li> 不要在类中使用过多的基本类型。：就是说，用其他的类代替多个相关的基本类型的使用。这样会使类更加易于理解且易于修改。
     *     <li> 不是所有的域都需要独立的域访问器和域更改器。
     *     <li> 将职责过多的类进行分解。 ：如果明显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解
     *     <li> 类名和方法名要能够体现它们的职责。
     *     <li> 优先使用不可变的类。
     * </ol>
     */
    public static void classAndObject(){
        // 要想构造一个Date对象，需要在构造器前面加上new操作符;
        new Date(); // 这个表达式构造了一个新对象，

        /*
         * 通常，希望构造的对象可以多次使用，因此，需要将对象存放在一个变量中：
         * 一定要认识到：一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
         * 在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。
         * new操作符的返回值也是一个引用。
         * 表达式new Date()构造了一个Date类型的对象，并且它的值是对新创建对象的引用。这个引用存储在变量now中。
         */
        Date now = new Date();

        // 可以显示地将对象变量设为null，表明这个对象变量没有引用任何对象。
        Date date = null;


    }

    /**
     * 私有域
     */
    private String name;

    /**
     * 可以将实例域定义为final。构建对象时必须初始化这样的域。
     * 也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。
     *
     * <p> final修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域
     * （如果类中的每个方法都不会改变其对象，这种类就是不可变的类。例如，String类就是一个不可变的类）。
     */
    private final int tag = 0;
    private final int id;

    /**
     * 如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。
     * 它属于类，而不属于任何独立的对象。
     */
    private static final String GROUP = "com.dongfeng.cn";


    /**
     * <p> ● 构造器与类同名
     * <p> ● 每个类可以有一个以上的构造器
     * <p> ● 构造器可以有0个、1个或多个参数
     * <p> ● 构造器没有返回值
     * <p> ● 构造器总是伴随着new操作一起调用
     */
    public JavaBasic(int id){
        this.id = id;
    }
    public JavaBasic(String name, int id){
        // 调用另一个构造器
        this(id);
        this.name = name;
    }
    public JavaBasic(int id, String name){
        this.name = name;
        this.id = id;
    }

    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }

    @Override
    public boolean equals(Object obj){
        if (this == obj){
            return true;
        }
        if (obj instanceof JavaBasic){
            /*
             * 方法可以访问所调用对象的私有数据。可以访问所属类的所有对象的私有数据。
             * JavaBasic类的方法可以访问JavaBasic类的任何一个对象的私有域。
             */
            return this.name.equals(((JavaBasic) obj).name);
        }
        return false;
    }

    // 在Java中，为了实现一个私有的方法，只需将关键字public改为private即可。

    /**
     * 静态方法是一种不能向对象实施操作的方法。
     * <p> 可以认为静态方法是没有this参数的方法。（静态方法中不能使用this）
     *
     * <p> 在下面两种情况下使用静态方法：
     * <lo>
     *     <li> 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow） </li>
     *     <li>  一个方法只需要访问类的静态域 </li>
     * </lo>
     */
    public static String sayHello(){
        // 静态方法不能访问实例域（因为静态方法是没有this参数的）
        // 静态方法可以访问自身类中的静态域
        return "Hello! group is "+ GROUP + " and current time is " + System.currentTimeMillis();
    }


    /**
     * <b> 方法参数的传递方式 : Java程序设计语言总是采用按值调用 </b>
     *
     * <p> 方法参数的传递方式 :
     * 按值调用（call by value）表示方法接收的是调用者提供的值。而按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。
     * 一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。
     *
     * <p> Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。
     *
     * <p> 方法参数共有两种类型：
     * <p> ● 基本数据类型（数字、布尔值）。
     * <p> ● 对象引用。
     *
     * <p> Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。
     *
     * <p> 下面总结一下Java中方法参数的使用情况：
     * <p> ● 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
     * <p> ● 一个方法可以改变一个对象参数的状态。
     * <p> ● 一个方法不能让对象参数引用一个新的对象。
     */
    public static void methodParameters(){

        int percent = 10;
        // 调用这个方法之后，percent的值还是10
        tripleValue(percent);
        /*
         * 具体的执行过程：
         * 1）x被初始化为percent值的一个拷贝（也就是10）。
         * 2）x被乘以3后等于30。但是percent仍然是10。
         * 3）这个方法结束之后，参数变量x不再使用。
         */


        // 一个方法不可能修改一个基本数据类型的参数。而对象引用作为参数就不同了:

        JavaBasic basic = new JavaBasic("myName", 12345);
        // 可以很容易地利用下面这个方法实现将一个JavaBasic对象的名称改为newName的操作：
        changeName(basic);
        System.out.println(basic.name);
        /*
         * 具体的执行过程为：
         * 1）x被初始化为basic值的拷贝，这里是一个对象的引用。
         * 2）changeName方法应用于这个对象引用。x和basic同时引用的那个JavaBasic对象的姓名属性改成了newName。
         * 3）方法结束后，参数变量x不再使用。当然，对象变量basic继续引用那姓名属性改成了newName的JavaBasic对象。
         *
         * 由此可以看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。
         * ●●● 但是，变量basic引用的还是原来的对象。这一点并没有改变。所以还是按值调用。对象引用是按值传递的。
         */
    }
    private static void tripleValue(int x){
        x = 3*x;
    }
    public static void changeName(JavaBasic x){
        x.setName("newName");
    }

    /**
     * 如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。
     * 这里的域也包括静态域。
     * <p> 很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时，其状态会设置为适当的默认值。
     * 如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。
     *
     * <p> 这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量。但是，如果没有初始化类中的域，将会被自动初始化为默认值（0、false或null）。
     */
    private int age;
    private static int H;

    /**
     * <p> 一个对象变量（例如，变量t）可以指示多种实际类型的现象被称为多态（polymorphism）。
     * <p> 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。
     * 而动态绑定实现的机制就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类。
     *
     * <p> 可以将子类对象赋给超类变量。子类型的对象可以赋值给父类型的引用变量，这叫向上转型
     * <p> 不能将一个超类的引用赋给子类变量。
     *
     */
    public static void polymorphism(){
        Tings[] tingsArray = new Tings[2];
        tingsArray[0] = new Tings(2545646);
        tingsArray[1] = new Goods(13546, "手机", "小米13 pro", 1, 6999);

        for (Tings t : tingsArray) {
            // 请注意，尽管这里将t声明为Tings类型，但实际上t既可以引用Tings类型的对象，也可以引用Goods类型的对象。
            // 虚拟机知道t实际引用的对象类型，因此能够正确地调用相应的toString方法。
            System.out.println(t.toString());
        }

        /*
         * 弄清楚如何在对象上应用方法调用非常重要。下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：
         * 1）编译器查看对象的声明类型和方法名。
         * 2）接下来，编译器将查看调用方法时提供的参数类型。
         * 3）如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，
         *   我们将这种调用方式称为静态绑定（static binding）。
         * 4）当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。
         *
         * 动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。
         * 假设增加一个新类Executive，并且变量t有可能引用这个类的对象，我们不需要对包含调用t.toString()的代码进行重新编译。
         * 如果t恰好引用一个Executive类的对象，就会自动地调用Executive.toString()方法。
         */

        /*
         * 将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。
         * 在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instanceof操作符就可以实现。
         * ● 只能在继承层次内进行类型转换。
         * ● 在将超类转换成子类之前，应该使用instanceof进行检查。
         */
        if (tingsArray[1] instanceof Goods){
            String name = ((Goods) tingsArray[1]).getName();
        }
    }


    public final void finalDemo(){
        /*
         * 不允许扩展的类被称为final类。如果在定义类的时候使用了final修饰符就表明这个类是final类。
         * 类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（final类中的所有方法自动地成为final方法）。
         * 将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。
         */
        System.out.println("this is a final method!");
    }

    public static void accessModifier(){
        /*
         * 1）仅对本类可见——private。
         * 2）对所有类可见——public。
         * 3）对本包和所有子类可见——protected。
         * 4）对本包可见——默认（很遗憾），不需要修饰符。
         */
    }


    public static void classRun(){
        /*
         * 在Java中，所谓类的加载是指将类的相关信息加载到内存。
         * 在Java中，类是动态加载的，当第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载，如果没有，则会加载其父类。
         *  1）一个类的信息主要包括以下部分：
         *    ❑ 类变量（静态变量）；
         *    ❑ 类初始化代码；
         *    ❑ 类方法（静态方法）；
         *    ❑ 实例变量；
         *    ❑ 实例初始化代码；
         *    ❑ 实例方法；
         *    ❑ 父类信息引用。
         * 2）类初始化代码包括：
         *    ❑ 定义静态变量时的赋值语句；
         *    ❑ 静态初始化代码块。
         * 3）实例初始化代码包括：
         *    ❑ 定义实例变量时的赋值语句；
         *    ❑ 实例初始化代码块；
         *    ❑ 构造方法。
         * 4）类加载过程包括：
         *    ❑ 分配内存保存类的信息；
         *    ❑ 给类变量赋默认值；
         *    ❑ 加载父类；
         *    ❑ 设置父子关系；
         *    ❑ 执行类初始化代码。
         */

        /*
         * 注意，类初始化代码，是先执行父类的，再执行子类的。不过，父类执行时，子类静态变量的值也是有的，是默认值。
         * 对于默认值，我们之前说过，数字型变量都是0, boolean是false, char是'\u0000'，引用型变量是null。
         */
    }
}
